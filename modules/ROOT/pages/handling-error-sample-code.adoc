= Handling Common Errors in Node SDK v2.6

[abstract]
Insert abstract here

== Better title than I can come up with
The errors we focus on here are *Timeout* and *NetworkError*, as well as *TemporaryError* (aka *TemporaryFailure*). The first two of these fall into a class of ambiguous errors, meaning they're not explicitly a success or failure, and as such we must handle them with care, especially when retrying.

Throughout these examples we will be assuming the following setup:
[source,javascript]
----
const couchbase = require('couchbase')
const CBErr = couchbase.errors
const N1qlQuery = couchbase.N1qlQuery

const cluster = new couchbase.Cluster('[ClusterAddress]')
cluster.authenticate('[username]', '[password')
const bucket = cluster.openBucket('default')
----

For convenience we also have a custom error class `RetriesExceededError` to have a cleaner way to break a retry loop
[source,javascript]
----
class RetriesExceededError extends Error {
    constructor(message) {
        super(message);
        this.name = "RetriesExceededError"
    }
}
----

== GET Operations
GET is the simplest operation to deal with, as there's no chance we made a change, so there's no risk to retrying a GET. The difficult part is deciding when to _stop_ retrying if we aren't getting a response back.

This example shows a recursive retry function that employs *exponential backoff*. There are of course several https://example.com[backoff alternatives] but this is one of the simplest to implement. All of the examples on this page will return their results using callbacks - following suit from the direct sdk calls.

[source,javascript]
----
function getOrRetry(key, callback, retries=2, delay=1000, backoff_factor=1){
    bucket.get(key, function(err, res){
        if(err && (err.code == CBErr.timedOut || err.code == CBErr.networkError || err.code == CBErr.temporaryError)){
            if(retries > 0){
                setTimeout(() => getOrRetry(key, callback, retries-1, delay*backoff_factor, backoff_factor), delay)
            } else {
                callback(new RetriesExceededError())
            }
        } else {
            callback(err, res)
        }
    })
}
----

An alternative to retrying is to get the document from a replica; i.e. from a different node on the cluster, in the case that the node required is not available, but (at least some of) the rest of the cluster is. 

WARNING: This method always has a chance to return *stale data*, so make sure only to use it in appropriate contexts. 
E.g:{nbsp}Get largely static data about, say, an airport - pretty safe. Airline ticket reservations - absolutely not. 

[source,javascript]
----
function getNormalOrReplica(key, callback){
    bucket.get(key, function(err, res){
        if(err.code == CBErr.timedOut || err.code == CBErr.networkError){
            bucket.getReplica(key, callback)
        } else {
            // Either we succeeded first time, or got a different error
            // In both instances we simply notify the callback
            callback(err, res)
        }
    })
}
----

Putting these examples together we can implement the replica read as a "last resort".
[source,javascript]
----
function getRetryThenReplica(key, callback){
    getOrRetry(key, function(err, res){
        if(err instanceof RetriesExceededError){
            // Could manually log a failure here - notify an admin that replica had to be used
            getNormalOrReplica(key, callback)
        } else {
            callback(err, res)
        }
    }, 2, 1000, 2)
}
----

While this combination may seem like a catch-all solution, it's important to remember that this won't always get you an answer. Sometimes the best solution is just to throw an error in the application - there's nothing you can do if the app has lost all network access.
What's more, it can be detrimental in some cases. If the relevant active node is semi-permanently down, all this solution does is add whatever timeout was used (here 4 seconds total) before successfully getting from a replica. This is where monitoring can come in useful, see *later on this page...*

== SET and UPSERT Operations
Getting a hard failure (eg [MAKE LIST HERE]) from either of these operations is safe to retry immediately. 
What's more difficult to deal with is the ambiguous errors we're working with: Timeouts and NetworkErrors. For simple cases (ie idempotent operations), retrying is usually safe - especially when combined with checking cas values.

In the case of a SET, a retry could fail with a *KeyAlreadyExists* error - which would be confirmation that the original operation succeded (or that it would have failed because a document was already present). The code for this follows the exact same format as the *getOrRetry* sample above, with an extra `else if` clause to handle the *KeyAlreadyExists* error.
[source,javascript]
----
} else if(err && err.code == CBErr.keyAlreadyExists) {
    callback(err, res) // <1>
}
----
<1> Bear in mind that the `res` here wouldn't be the exact same as for a successful SET, so it's up to you to decide how that should be handled, or whether to return a static value or `null` here.

Retrying an UPSERT on the other hand, would simply overwrite the document with our version, had it already been changed.
(Again this would be identical to *getOrRetry* but instead calling `bucket.upsert`)

For http://HOVER_WOULD_BE_BETTER[non-idempotent] operations, it's important to track the document's CAS value so it's not overwritten without checking its new content.
In the case that our initial attempt at an UPSERT with CAS is either timed-out or the connection is dropped early, we lose the ability to know if _we_ or _someone else_ edited the document. Unless there's already some structure in your application logic that could be used to check in these cases who the last edit came from, we recommend taking a look at http://BLOGPOST[this blog post] which explains this mechanism fully and has more in depth code samples.

== N1QL Queries and Replicas
The errors we deal with on this page are usually caused by a node dropping out, or a loss of network connection. In some of these cases, trying a N1QL query may fail outright.
However, it may still be possible to get all of the query results where there's only a partial failure (i.e: when a minority of data nodes drop).
This depends on 2 conditions:

* The Query and Index nodes/services are still available
* The WHERE clause only operates on a fully indexed field

While this seems like a strict requirement, it may still be useful for your application
For example, in the couchbase travel-sample app, a common query is to search for airports:

[source,n1lq]
----
// Matches any airports where our search fits their FAA code (eg MAN, LHR) 
SELECT airportname FROM `travel-sample` WHERE POSITION(faa, $val) = 0
----

In the case described, the result of running this query would be a timeout error - as the query tries to access the documents on the failed node to get the airport names.
But we can still get data directly from the index we're using (the FAA index). For example, both of the following queries would work:

[source,n1lq]
----
SELECT faa FROM `travel-sample` WHERE POSITION(faa, $val) = 0
SELECT meta().id FROM `travel-sample` WHERE POSITION(faa, $val) = 0
----

The latter of these queries gives us all the document IDs for the results. This is useful because we can now fetch the documents ourselves, choosing to either

A. Get only the documents that are available on their active nodes
B. Get the active docs, and the replicas for the remaining docs

Here's a code sample showing option B:
[source,javascript]
----
const q = N1qlQuery.fromString("SELECT airportname FROM `travel-sample` WHERE POSITION(faa, $val) = 0")
const simple_q = N1qlQuery.fromString("SELECT meta().id FROM `travel-sample` WHERE POSITION(faa, $val) = 0")

function N1QLFetchAirports(search, callback) {
    let param = search.toLowerCase()

    bucket.query(q, [param], (err, rows) => {
        if(err && err.code == CBErr.timedOut){

            // If the original query timed out, try the simple one
            bucket.query(simple_q, [param], (err, rows) => {

                // An error here means we just give up
                if(err) return callback(err)

                // Get the document IDs as a list, so we can getMulti them
                let IDs = rows.map(x => x.id)
                bucket.getMulti(IDs, (num_errs, get_rows) => {

                    // Filter for keys that got an error response, and get them from replicas
                    IDs = IDs.filter(x => get_rows[x].error)
                    bucket.getMultiReplica(IDs, (num_errs, replica_rows) => { // <1>
                        // Log failed gets
                        console.log("Failed to get", num_errs, "documents")
                        // Concatenate results, then format to match normal output
                        get_rows = {...get_rows, ...replica_rows}
                        let results = Object.keys(get_rows).map(k => ({
                            airportname: get_rows[k].value.airportname,
                            city: get_rows[k].value.city
                        }))
                        callback(err, results)
                    })
                })
            })
        } else {
            // Original query hard-failed
            callback(err, rows)
        }
    })
}
----
<1> The function *getMultiReplica* isn't actually implemented, but is simply performing getReplica in a loop (concurrently), and waiting until all responses have arrived.
